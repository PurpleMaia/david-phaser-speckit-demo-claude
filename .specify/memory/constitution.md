<!--
Sync Impact Report
==================
Version: 1.1.0 → 1.2.0 (Cross-Platform Playability Added)

Added Sections:
- Principle VI: Cross-Platform Playability (Phase 3: Mobile/Touch Controls)

Modified Principles:
- New principle added ensuring keyboard controls remain primary while adding touch support
- Specified on-screen control design constraints aligned with existing visual style
- Clarified conflict resolution: keep both usable, mobile may be slightly simpler

Files Updated:
- ✅ .specify/memory/constitution.md (this file)
- ⏳ .specify/templates/spec-template.md (should reference cross-platform requirements)
- ⏳ .specify/templates/plan-template.md (Constitution Check should verify control compatibility)

Follow-up TODOs:
- Consider updating spec template to include Input Methods section for mobile/desktop
- Consider updating plan template Constitution Check to verify keyboard controls remain intact

Previous Changes (v1.0.0 → 1.1.0):
- Added Visual Style Guide as subsection under Principle III
- Specified color palette, shading, and SVG generation approach
-->

# Phaser 3 SpecKit Demo Constitution

## Core Principles

### I. Simplicity First

Every implementation choice MUST prioritize simplicity over features, flexibility, or
optimization. When faced with a decision between a "fancy feature" and a "simple, robust
implementation", always choose simple.

- Code MUST be readable and self-explanatory
- Project structure MUST remain minimal and standard
- New abstractions are prohibited unless strictly necessary to avoid duplication
- Premature optimization is prohibited

**Rationale**: This is a proof-of-concept demo for SpecKit + Codex CLI. The goal is to
demonstrate workflow, not build a production game. Simple code ensures the demo remains
understandable and maintainable.

### II. Minimal Dependencies

The project MUST avoid adding new libraries or dependencies unless strictly necessary for
core functionality.

- Phaser 3 and Vite (or equivalent modern bundler) are the only approved non-trivial dependencies
- Standard npm tooling (scripts, dev server) is permitted
- Each proposed dependency MUST include written justification explaining why existing tools
  cannot solve the problem

**Rationale**: Keeping dependencies minimal reduces bundle size, simplifies setup, ensures
the demo runs reliably with just `npm install && npm run dev`, and prevents scope creep.

### III. Code-Generated SVG Assets (NON-NEGOTIABLE)

All visual assets MUST be SVGs generated by code. Bitmap files (.png, .jpg, etc.) are
strictly prohibited.

- SVGs MUST be defined as inline `<svg>` strings or as separate `.js` modules exporting
  SVG strings
- Phaser MUST load them via data URIs or equivalent pipeline (no external file loading)
- Art style MUST be extremely simple: colored shapes, basic icons, geometric primitives
- No attempt at "good art" is required or expected

**Rationale**: Code-generated SVGs eliminate asset management complexity, keep the repository
lightweight, ensure reproducibility, and align with the experimental/demo nature of the
project.

#### Visual Style Guide (Phase 2: Visual Polish)

Target aesthetic: **"simple but charming"** — early Zelda/SNES vibes with modern clarity.

**Design Constraints:**
- **Clean silhouettes**: Player, NPCs, and environment elements MUST have clear, readable shapes
- **Color contrast**: Player, NPCs, and environment MUST be visually distinct through color choices
- **Tiny color palette**: Use 10–16 total colors maximum across the entire game
- **Soft outlines and simple shading**: Each base color gets ONE darker shade for depth (no gradients, no complex lighting)

**Implementation Approach:**
- **Prefer parametric, reusable SVG generators** over one-off drawings
  - Example: `createCharacterSvg({ bodyColor, accessoryColor, emotion })`
  - This aligns with code-first asset generation and reduces duplication
- **Mechanics and code clarity still beat visual effects**: Don't add particle systems, animations, or effects that complicate the codebase unless they serve gameplay
- Visual polish MUST NOT compromise Principle I (Simplicity First) or Principle II (Minimal Dependencies)

### IV. Local-First Execution

The entire project MUST run locally without external dependencies, servers, or databases.

- Frontend-only web app (no backend, no API calls, no database)
- `npm install` followed by `npm run dev` (or equivalent) MUST be sufficient to run
- All game state MUST be client-side only (browser memory, localStorage if needed)
- No network requests during gameplay

**Rationale**: Local-first ensures the demo is portable, works offline, requires no
infrastructure, and can be easily shared, cloned, and run by anyone.

### V. Standard Project Structure

Project organization MUST follow standard conventions for modern JavaScript web projects.

- Clear separation: `src/` (source code), `public/` or `assets/` (if needed for build output)
- Entry point clearly identified (e.g., `src/main.js` or `src/index.js`)
- Configuration files at repository root (package.json, vite.config.js, etc.)
- README.md MUST explain how to run the game and what to expect

**Rationale**: Standard structure makes the project immediately familiar to developers,
reduces cognitive load, and demonstrates best practices for SpecKit-managed projects.

### VI. Cross-Platform Playability

The game MUST remain fully playable with keyboard controls on desktop while also supporting
touch controls on mobile devices.

- Keyboard controls MUST remain the primary input method and MUST NOT be degraded
- Touch controls MUST be added as an additional input method for mobile devices
- On-screen controls MUST be visually simple and consistent with the SVG style guide
- On-screen controls SHOULD avoid covering the main gameplay area more than necessary
- Control UI MUST prefer clarity and reliability over fancy UI effects
- When conflicts arise between mobile UX and desktop UX, both MUST remain usable
- Mobile controls MAY be slightly simpler than desktop controls when necessary

**Rationale**: Cross-platform support expands accessibility without compromising the core
desktop experience. Simple, reliable touch controls align with the Simplicity First principle
while making the demo playable on a wider range of devices.

## Technical Constraints

### Toolchain

- **Framework**: Phaser 3 (latest stable version)
- **Build Tool**: Vite + JavaScript (TypeScript permitted only if strongly justified)
- **Package Manager**: npm (lock file required)
- **Target Environment**: Modern browsers (ES2020+, no IE support needed)

### Asset Pipeline

- SVG definitions in `src/assets/` as `.js` modules exporting strings
- Data URI conversion handled in asset loader or build pipeline
- No external file loading during runtime
- No sprite sheets or texture atlases unless code-generated

### Testing

- Testing is OPTIONAL for this demo project
- If included, a minimal sanity test (e.g., script assertion, smoke test) is sufficient
- Testing MUST NOT block delivery of a running demo
- Focus on "does it run and display something" over comprehensive coverage

## Development Workflow

### Decision Framework

When making implementation choices, apply this decision tree:

1. **Does it add complexity?** → If yes, reject unless absolutely required
2. **Does it require a new dependency?** → If yes, document justification or find simpler alternative
3. **Does it increase bundle size significantly?** → If yes, evaluate if benefit justifies cost
4. **Does it make the code harder to read?** → If yes, choose clearer alternative

### Quality Standards

- Code MUST be formatted consistently (use Prettier or equivalent)
- README MUST be kept up-to-date with setup and run instructions
- Commit messages SHOULD be clear and descriptive
- Bundle size SHOULD remain reasonable but optimization is not a priority

### Scope Control

- Feature requests MUST be evaluated against "Simplicity First" principle
- Any feature that cannot be implemented in <100 lines of clear code requires justification
- Game mechanics MUST remain minimal: basic movement, simple interactions, tiny world
- This is a demo, not a game: prefer "proof of concept" over "complete experience"

## Governance

### Amendment Procedure

1. Constitution changes MUST be documented with version bump rationale
2. Breaking changes to principles require MAJOR version increment
3. New principles or expanded guidance require MINOR version increment
4. Clarifications and typo fixes require PATCH version increment
5. All amendments MUST include Sync Impact Report updating dependent templates

### Compliance Review

- All feature specifications MUST reference relevant constitutional principles
- Implementation plans MUST include "Constitution Check" section validating compliance
- Any principle violation MUST be explicitly justified in planning documents
- Code reviews SHOULD verify adherence to Simplicity First and Minimal Dependencies principles

### Versioning

This constitution uses semantic versioning (MAJOR.MINOR.PATCH):

- **MAJOR**: Backward-incompatible governance changes, principle removals/redefinitions
- **MINOR**: New principles added, materially expanded guidance
- **PATCH**: Clarifications, wording improvements, typo fixes

**Version**: 1.2.0 | **Ratified**: 2025-11-24 | **Last Amended**: 2025-11-24
